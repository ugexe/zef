=pod

=encoding utf8

=head2 Name

Zef - Perl6 Module Management

=for HTML <a href="https://travis-ci.org/ugexe/zef"><img src="https://travis-ci.org/ugexe/zef.svg?branch=master"></a>

=head1 INSTALLATION

    git clone https://github.com/ugexe/zef.git
    cd zef
    perl6 -Ilib bin/zef -v install Zef

Be sure your `PATH` includes the file path shown by the command below:

    $ perl6 -e "say %*CUSTOM_LIB<site>.IO.child('bin').Str"
    # example: /home/perl6/install/share/perl6/site/bin
    
=head1 DESCRIPTION

Zef is a package manager for Perl6. It works with MoarVM and JVM on OSX, Windows, Linux, OSX, and other BSD derivatives.

=head3 Features

    * Optonal parallelization of precompilation and testing phases for quicker installs and CI results.
    * Complete HTTP grammar based on RFC7230-7235 (and others).
    * Zef::Net::HTTP::Client - a HTTP client based on included HTTP grammars.
    * CompUnitRepo based installs - uses rakudo's built in installer, letting the code focus on package management.
    * A `hooks` implementation as mentioned in L<S22|http://design.perl6.org/S22.html#hooks>, allowing module authors to even implement the entire build/test/install process without needing a package manager at all.
    * No external dependencies required. Can bootstrap itself from source using the same zef application used to install all other modules.

=head1 USAGE

=head1 The CLI

    # duh
    zef -v install CSV::Parser

    # noooooo!
    zef -v uninstall CSV::Parser

    # fire off test reports this time *onomatopoeia of an uzi*
    zef -v --report install CSV::Parser

    # search for module names matching `CSV::Parser`
    zef -v search CSV::Parser

    # META information about `CSV::Parser`
    zef -v info CSV::Parser

    # build project in current directory
    zef -v build

    # test project in current directory    
    zef -v test

    # fetch a specific module only
    zef -v get CSV::Parser

    # fetch a specific module, and shell into the directory it is saved to
    zef -v look CSV::Parser

    # build/test/install all modules in the ecosystem
    zef -v smoke

=head2 More CLI

=head4 B<install>

Fetch, build, test, optional report, and install.

    # verbose output
    -v

    # send a test report
    --report

    # parallel testing and precompilation
    --async

    # cut off lines that reach (our guess at) the term width in columns
    --no-wrap

    # no status bar or other CLI eye candy
    --boring

    # do everything except the actually install
    --dry

    # include library paths to the spawned processes
    # zef -v -lib=lib-old --lib=blib-old/lib build
    #  -> perl6 -Ilib-old -Iblib-old/lib <compiler/test commands>
    --lib

    # run the tests in a random order instead of sorted
    --shuffle

    # skip modules with matching names (or any modules depending on them)
    --ignore=Acme::Virus --ignore=Acme::TakesForever

    # sets Zef::Authority.projects based on supplied file instead of downloading
    --projects-file=projects.json

    # livin that multi thread life
    zef -v --report --async install HTTP::Server::Threaded
    
B<Example>: (note parallelized output format will be improved)
    
    $ zef -v install CSV::Parser P6TCI
    ===> Querying Authority [done]
    ===> Fetching [done]
    ===> Fetching OK for: CSV::Parser P6TCI
    ===> META.info availability OK for: CSV::Parser P6TCI
    ===> Build directory: /tmp/CSV--Parser/blib
    Parser.pm # perl6 -I/tmp/CSV--Parser/blib/lib -I/tmp/CSV--Parser/lib -I/tmp/CSV--Parser/lib --target=mbc --output=/tmp/CSV--Parser/blib/lib/CSV/Parser.pm.moarvm lib/CSV/Parser.pm
    ===> Build directory: /tmp/P6TCI/blib
    P6TCI.pm6 # perl6 -I/tmp/P6TCI/blib/lib -I/tmp/P6TCI/lib -I/tmp/P6TCI/lib --target=mbc --output=/tmp/P6TCI/blib/lib/P6TCI.pm6.moarvm lib/P6TCI.pm6
    ===> Building [done]
    ===> Build OK for: lib/CSV/Parser.pm lib/P6TCI.pm6
    01_multiline_csv.t  # perl6 --ll-exception -Iblib/lib -Ilib t/01_multiline_csv.t
    01_multiline_csv.t  # 1..1
    01_multiline_csv.t  # ok 1 -
    02_escaped_csv.t    # perl6 --ll-exception -Iblib/lib  -Ilib t/02_escaped_csv.t
    02_escaped_csv.t    # 1..1
    02_escaped_csv.t    # ok 1 -
    03_delimiters_csv.t # perl6 --ll-exception -Iblib/lib -Ilib t/03_delimiters_csv.t
    03_delimiters_csv.t # 1..1
    03_delimiters_csv.t # ok 1 -
    04_binary_csv.t     # perl6 --ll-exception -Iblib/lib -Ilib t/04_binary_csv.t
    04_binary_csv.t     # 1..1
    04_binary_csv.t     # ok 1 -
    00-load.t           # perl6 --ll-exception -Iblib/lib -Ilib t/00-load.t
    00-load.t           # ok 1 - Module loaded.
    00-load.t           # 1..1
    ===> Testing [done]
    ===> Testing OK for: 01_multiline_csv.t 02_escaped_csv.t 03_delimiters_csv.t 04_binary_csv.t 00-load.t
    ===> Installing [done]
    ===> Install OK for: CSV::Parser P6TCI


=head4 B<smoke>

Tests every module in the ecosystem, ignoring any modules with a name (or dependency name) matching argument C<*@ignores>

    snoop@cali:~/ zef -v --report smoke

    # skip modules with matching names (or any modules depending on them)
    --ignore=Acme::Virus --ignore=Acme::TakesForever

    # same as install options
    --boring
    --smoke
    --dry
    -v

=head4 B<search>

Take C<*%args> filters. That is, any C<--[field]="term"> passed will search for "term" in it's META [field].

Add a C<*> to any filter to have the filter apply a C<.starts-with()> filter using the string to the left of the C<*>.

Note: C<*> behaves slightly differently for C<--version>

    # search by name
    zef -v search Text::Table::Simple            # or zef -v --name="Text::Table::Simple"

    # search by version
    zef -v --version="*" search                  # Version filter only
    zef -v --version="*" search HTTP::Server     # Can search for 'whatevers'
    zef -v --version="0.1" search HTTP::Server   # Version matching
    zef -v --version="0.1+" search HTTP::Server  # Basic version ranges

    # search by other fields in META
    zef -v --depends="HTTP::Server" search       # Match `HTTP::Server` inside --`depends`

    # a naive substring search using a wildcard
    zef -v --depends="HTTP*" search              # Matches anything that $results.starts-with("HTTP")

    # sure
    zef -v --depends="HTTP::Server" --version="0.1+" search HTTP::Server::Threaded

B<Example>:

    $ zef -v search HTTP*
    ===> Querying Server [done]
    ===> Filtering Results [done]
    ===> Found 13 results
    ---------------------------------------------------------------------------------------------------------------------------------
    ID | Package                                      | Version | Description
    ---------------------------------------------------------------------------------------------------------------------------------
    1  | HTTP::Server::Simple                         | *       | Simple webserver module, with PSGI support
    2  | HTTP::UserAgent                              | 1.1.3   | Web user agent
    3  | HTTP::Easy                                   | *       | HTTP servers made easy, including PSGI
    4  | HTTP::Status                                 | *       | Get the text message associated with an HTTP status code
    5  | HTTP::Client                                 | *       | A flexible HTTP Client library
    6  | HTTP::ParseParams                            | 1.0.0   | cookie/query/post data parsing
    7  | HTTP::Server::Async                          | 0.1.0   | Asynchronous Base HTTP Server
    8  | HTTP::Server::Async::Plugins::Router::Simple | 0.1.0   | Basic routing for http server
    9  | HTTP::Server::Threaded                       | 0.1.0   | Threaded Base HTTP Server
    10 | HTTP::Server::Router                         | 0.1.0   | Router for HTTP::Server based servers
    11 | HTTP::Server                                 | 0.1     | role for HTTP::Server so we can have start building out some ser...
    12 | HTTP::Server::Logger                         | 0.1     | A common log format logger for anything abiding by HTTP::Server
    13 | HTTP::Headers                                | 0.1     | Tools for working with HTTP message headers
    ---------------------------------------------------------------------------------------------------------------------------------

=head4 B<info>

Given C<*@modules> it will list a formatted version of each's C<META.info> data.
    
    # basics
    zef info JSON::Tiny

    # -v to also list:
    #   * `provides` section
    #   * Entire dependency chain, ordered and grouped into build levels
    zef -v info Task::Star

B<Example>:

    $ zef -v info HTTP::UserAgent
    ===> Querying Server [done]
    ===> Filtering Results [done]
    ===> Found 1 results
    [HTTP::UserAgent]
    # Version: 1.1.3
    # Author:        github:sergot
    # Description:   Web user agent
    # Source-url:    git://github.com/sergot/http-useragent.git
    # Provides: 9 items
    #       HTTP::Cookies
    #       HTTP::Message
    #       HTTP::UserAgent::Common
    #       HTTP::Header::Field
    #       HTTP::Request
    #       HTTP::Header
    #       HTTP::Cookie
    #       HTTP::Response
    #       HTTP::UserAgent
    # Depends: 7 items
    #   0)  HTTP::Status
    #   1)  File::Temp
    #   2)  DateTime::Parse
    #   3)  IO::Capture::Simple
    #   4)  Encode
    #   5)  MIME::Base64
    #   6)  URI
    # Depends-chain:
    #   0.0) DateTime::Parse
    #   0.1) Encode
    #   0.2) File::Directory::Tree
    #   0.3) HTTP::Status
    #   0.4) IO::Capture::Simple
    #   0.5) MIME::Base64
    #   0.6) URI
    #   1.0) File::Temp
    #   2.0) HTTP::UserAgent

=head1 DEVELOPMENT

=head2 Zef::Distribution

The base project class containing path and META information.

    my $dist = Zef::Distribution.new(:path($*CWD));

=head2 Zef::Roles::Hooking

Methods to execute the hooks located in C<hooks/>. Hooks are chosen based on matching the phase and modifier.

    # Phases available to hook: `enum Phase <BUILD TEST INSTALL>`

    my $dist = Zef::Distribution.new(:path($*CWD));
    $dist does Zef::Roles::Processing;
    $dist does Zef::Roles::Precompiling;
    $dist does Zef::Roles::Installing;
    $dist does Zef::Roles::Hooking;

    # build + hooks
    $dist.queue-processes: [$dist.hook-cmds(BUILD, :before)];
    $dist.queue-processes($_) for $dist.precomp-cmds;
    $dist.queue-processes: [$dist.hook-cmds(BUILD, :after)];
    await $dist.start-processes;

    # install + hooks
    $dist.queue-processes: [$dist.hook-cmds(INSTALL, :before)];
    await $dist.start-processes;
    $dist.install;
    $dist.queue-processes: [$dist.hook-cmds(INSTALL, :after)];
    await $dist.start-processes;

The following filenames are suggested:
C<before-test.pl6> C<after-test.pl6> C<before-build.pl6> C<after-build.pl6> C<before-install.pl6> C<after-install.pl6>

However, we only match the beginning and end of the filename, so you may have multiple files for any phase/modifier:
i.e.: C<before-1-test.pl6> C<before-2-test.pl6>

=head2 Zef::Roles::Installing

Allows a C<Zef::Distribution> to install

    my $dist = Zef::Distribution.new(:path($*CWD));
    $dist does Zef::Roles::Installing;
    $dist.install;

=head2 Zef::Roles::Precompiling

Allows a C<Zef::Distribution> to generate the commands, in order, to precompile a distribution's C<provides>

Combine with C<Zef::Roles::Processing> to execute these commands.

    my $dist = Zef::Distribution.new(:path($*CWD));
    $dist does Zef::Roles::Precompiling;    

=head2 Zef::Roles::Testing

Allows a C<Zef::Distribution> to generate the commands, in order, to test all files with a C<.t> extension in a distribution's C<t/> directory

Combine with C<Zef::Roles::Processing> to execute these commands.

    my $dist = Zef::Distribution.new(:path($*CWD));
    $dist does Zef::Roles::Testing;    

=head2 Zef::Roles::Processing

    role Zef::Roles::Processing[Bool :$async]

    method queue-processes(*@groups) # add a process or group of processes to be executed together
    method start-processes           # execute each process (or group of processes) in order
    method passes                    # helper function to show name of processes where exitcode == 0
    method failures                  # helper function to show name of processes where exitcode > 0

Allows executing commands, including grouped commands in parallel if C<:$async> is true (i.e. C<[[$proc1, $proc2],[$proc3]]> executes C<$proc1> and C<$proc2> at the same time, and then C<$proc3> after both previous processes finish)

    my $dist = Zef::Distribution.new(:path($*CWD));
    $dist does Zef::Roles::Precompiling;
    $dist does Zef::Roles::Testing;
    $dist does Zef::Roles::Installing;
    $dist does Zef::Roles::Processing[:!async];

    $dist.queue-processes( [$_.list] ) for [$dist.precomp-cmds, $dist.test-cmds];
    await $dist.start-processes;
    await $dist.install;

=head1 INCLUDED TOOLS

=head2 Zef::Net::HTTP

HTTP library interfaces and Grammars.

    use Zef::Net::HTTP::Client;
    
    my $client = Zef::Net::HTTP::Client.new(:auto-check);

    my $body     = to-json({ term => "zef" });
    my $response = $client.post("http://httpbin.org/post", :$body);

    # .content takes care of encoding. The .body attribute has the raw data for manual processing
    my $json     = from-json($response.content);

    my $response = $client.get("https://www.google.com");
    say $reponse.content; # returns $.body with encoding/chunked/etc applied

or build your own client by satisfying the interface requirements during object construction:

    use Zef::Net::HTTP::Client;

    use Different::Responder;
    use Different::Requestor;
    use You::Get::The::Idea;

    Zef::Net::HTTP::Client.new(              # Zef::Net::HTTP interface type
        responder   => Different::Responder, # HTTP::Response
        requestor   => Different::Requestor, # HTTP::Request
        transporter => You::Get::The::Idea   # HTTP::Transport
    );

=head1 NOTES

=head2 Links

L<Zef.pm|https://zef.pm/>

L<http://modules.perl6.org/>

=head2 Full Flex

 * ✓ No external dependencies
 * ✓ CompUnitRepo::Local based
 * ✓ Test reporting to P6C servers
 * Test reporting to Zef servers
 * Rotating OS smoke testing server integration
 * ✓ Use perl6 github ecosystem as an additional authority
 * ✓ HTTP library
 * HPACK/HTTP2 compatability
 * ✓ Parallelized testing
 * TAP Harness/Grammar
 * ✓ Parallelized building
 * ✓ Basic CLI overlay/hud
 * Pure Perl6 decompression/git-clone library

=cut
