=pod

=encoding utf8

=head2 WARNING

Only mostly works.

=head2 Name

Zef - Perl6 Module Management

=for HTML <a href="https://travis-ci.org/ugexe/zef"><img src="https://travis-ci.org/ugexe/zef.svg?branch=master"></a>

=head2 Description

L<Zef.pm|https://zef.pm/>

L<https://github.com/tony-o/perl-zefserver>

CPAN but better. Maybe?

=head1 USAGE

=head2 Module Management

    zef install CSV::Parser
    # duh

    zef uninstall CSV::Parser
    # noooooo!

    zef --report install CSV::Parser
    # fire off test reports this time *onomatopoeia of an uzi*

    zef search CSV
    # search modules names for CSV

=head2 Module Development

    zef build
    # build project in current directory
    
    zef test
    # test project in current directory
    
=head1 TOOLS

=head2 Zef::Net::HTTP::Client

Basic http client: Grammar based parser; uses IO::Socket::SSL if available for https.

    use Zef::Net::HTTP::Client;
    
    my $client = Zef::Net::HTTP::Client.new;

    my $body     = to-json({ term => "zef" });
    my $response = $client.post("http://zef.pm/api/search", :$body);
    my $json     = from-json($response.<body>);

    my $response = $client.get("https://www.google.com");
    say $reponse.content; # apply encoding/chunked/etc to $.body

=head2 Zef::Net::HTTP::Response

=head2 Zef::Net::HTTP::Request

=head2 Zef::Net::HTTP::Grammar

=head2 Zef::Net::URI

=head2 Zef::Net::URI::Grammar

=head2 Zef::Utils::Base64

Base64 encoding/decoding

    use Zef::Utils::Base64;

    my $b64 = Zef::Utils::Base64.new;

    say $b64.b64encode("Perl");
    # UGVybA==
    
    say $b64.b64decode("UGVybA==").decode('utf8');
    # Perl
    
=head2 Zef::Utils::PathTools;

Uses MONKEY-TYPING to add additional methods to L<IO::Path|http://doc.perl6.org/type/IO::Path>.

    use Zef::Utils::PathTools;
    
    say $*CWD.ls(:f, d => False)    
    # "/home/user/perl6/zef/META6.json".IO "/home/user/perl6/zef/META.info".IO "/home/user/perl6/zef/README.pod".IO

    $*CWD.ls(:f, :r, :a)
    # list all files recursively including dot files
    
    $*CWD.rm(:f, :d, :r);
    # (rm -rf) recursively delete files and folders
    
    $*CWD.mkdirs("new-dir/new-sub-dir");
    # (original mkdir does this already on MoarVM, but not JVM)
    
=head3 Methods/Subroutines

B<Note>: I<All methods have a corresponding subroutine>.

=head4 ls(IO::Path:D $path, :f => True, :d => True, :r => False, :a => False)

List files and/or folders for a path.

    # ls FILTERS
    :f - file
    :d - directory
    :r - recursive
    :a - all (otherwise dot files/folders ignored)
    
=head4 rm(IO::Path:D $path, :f => True, :d => False, :r => False, :a => False)

Delete files and/or folders for a given path.

    # rm FILTERS
    :f - file
    :d - directory
    :r - recursive
    :a - all (otherwise dot files/folders ignored)
    
=head4 mkdirs(IO::Path:D $path, :mode => 0o777)

Create new path, including non-existant parent directories.

=head2 Zef::Utils::Depends

Utilities for extracting dependencies from Perl6 projects/code.
    
    use Zef::Utils::Depends;
    use Zef::Utils::PathTools; # for .ls
    
    my @libs    = $lib-dir.IO.ls(:r, :f, d => False);
    my @depends = Zef::Utils::Depends.build-dep-tree: extract-deps(@libs);

=head3 Methods/Subroutines

=head4 extract-deps(*@paths)

Attempt to extract dependencies via source parsing.

    use Zef::Utils::Depends;
    
    say extract-deps("lib/Zef.pm6").perl
    # ({:dependencies(["Zef::Authority", "Zef::Builder", "Zef::Config", "Zef::Exception", "Zef::Getter", "Zef::Installer", "Zef::Reporter", "Zef::Tester", "Zef::Uninstaller", "Zef::Utils::Base64", "Zef::Utils::Depends", "Zef::Utils::PathTools"]), :file("lib/Zef.pm6"), :name("Zef")},)

=head4 build-dep-tree(*@meta-files, :$target)

Build dependency order/tree from a list of dependency meta files. If :$target is passed then the tree will built with :$target as the base node.

=head1 NOTES

=head2 Full Flex

 * Test reporting to Zef servers
 * Rotating OS smoke testing server integration
 * ✓ Use perl6 github ecosystem as an additional authority
 * ✓ Small http client

=cut
